;
; SlidingHeap module - a memory manager that works by using 'anchor points'
; Copyright (C) 1992  Steven Haslam
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;


; Notes on changes for compatibility with 32-bit ARM modes
; ========================================================
;
; Since the original source code has been mislaid, this disassembly was
; generated automatically by Armalyser and further optimised and modified by
; hand. It is suitable for use with ObjAsm.
;
; In 26-bit mode caller flags are preserved by the SWI handler (except for
; setting V on error). In 32-bit mode, caller flags are not preserved by
; SlidingHeap SWIs.
;
; Single-register LDM/STMs have been replaced with LDR/STRs, since this is
; faster on some new processors.
;
; The old module explicitly enabled interrupts on entry to its SWI handler.
; This behaviour has been removed, since there seems little point and it may
; actually be counter-productive.
;
;
; The module no longer corrupts R0 (pointer to heap base) by default on exit
; from SWIs, making it easier to use from assembler.
;
; Christopher Bazley (chrisbazley@bigfoot.com), 26th October 2002
; Harriet Bazley (harriet.bazley@blueyonder.co.uk), 29th October 2002


; Errors + numbers
; &000001E6 "Unknown SlidingHeap operation"                 [UNKNOWN SWI]
; &00C02800 "No more free slots in heap"                    [NewBlock]
; &00C02802 "You must have at least one block in the heap!" [Create]
; &00C02803 "Heap ID corrupted (Bad signature)"             [VerifyHeap]
; &00C02804 "Start of heap corrupted (Bad signature)"       [VerifyHeap]
; &00C02805 "Top of heap corrupted (Bad signature)"         [Unused!]
; &00C02807 "Couldn't find anchor in heap (ScrapBlock)"     [ScrapBlock]
; &00C02808 "Couldn't find anchor in heap (ExtendBlock)"    [ExtendBlock]
; &00C02809 "Unable to decrease number of slots in heap"    [IncreaseSlots]
; &00C0280A "Heap is not in valid memory"                   [VerifyHeap]
; &00C0280B "Couldn't find anchor in heap (DescribeBlock)"  [DescribeBlock]

; Same position in 26-bit mode PC and 32-bit mode PSR
V_flag * (1<<28)
; used in constructing error blocks - first word occupied by error number
short_workspace * (256-4)

; Armalyser analysis of IDEFS::Tamzin.$.Programming.SlidingHeap.SlidingHp

; Generated by Armalyser 0.33 (05-Sep-2002) DEEJ Technolgy PLC
; From IDEFS::Tamzin.$.Programming.SlidingHeap.SlidingHp

XOS_Module                       EQU &02001E
XOS_ValidateAddress              EQU &02003A
XOS_WriteS                       EQU &020001
XOS_ConvertHex8                  EQU &0200D4
XOS_Write0                       EQU &020002
XOS_ConvertCardinal4             EQU &0200D8
XOS_ConvertFixedFileSize         EQU &0200EB
XOS_WriteC                       EQU &020000
XOS_SubstituteArgs               EQU &020043
XOS_WriteI                       EQU &020100
XOS_ReadUnsigned                 EQU &020021

        AREA |SlidingHp$$Code|, CODE, READONLY

        ORG      &0

|L00000000.Module_Header.Offset|
        DCD     &00000000                        ; Start offset
        DCD     |L0000013C.Initialisation_code|  ; Initialisation offset
        DCD     |L00000154.Finalisation_code|    ; Finalisation offset
        DCD     &00000000                        ; Service call handler offset
        DCD     |L00000044.String|               ; Title string offset -> "SlidingHeap"
        DCD     |L00000050.String|               ; Help string offset  -> "Sliding Heap	2.12 (13 Oct 2003) 32-bit compatible"
        DCD     |L00000070.Command_Table.String| ; Help and command keyword table offset
        DCD     &000C0280                        ; SWI chunk base number
        DCD     |L00000168.SWI_handler_code|     ; SWI handler code offset
        DCD     |L000000CC.SWI_Table.String|     ; SWI decoding table offset
        DCD     &00000000                        ; SWI decoding code offset
        DCD     0 ; No MessageTrans file
        DCD     module_flags ; Flags word offset

module_flags
        DCD     1 ; flags word (32-bit compatible)

|L0000002C.String|
        DCB     "© Steven Haslam 1992",0   ;~~ String -/-
|L00000044.String|
        DCB     "SlidingHeap",0                  ; String -/- (referenced)
|L00000050.String|
        DCB     "Sliding Heap\t2.11 (16 Dec 2002) 32-bit compatible",0 ; String -/- (referenced)
        ALIGN

|L00000070.Command_Table.String|
        DCB     "HeapInfo",0                     ; Command Table: Command
        ALIGN
        DCD     |command1|              ; Command Table: Code offset    -> Code @ &00000BD4
        DCD     &00010101                        ; Command Table: Infomation Word
        DCD     |syntax1|            ; Command Table: Syntax offset  -> String array: "Syntax: *HeapInfo <address>",0
        DCD     |help1|               ; Command Table: Help offset    -> String array: "*HeapInfo will display information on the given sliding heap.\r\rS"
        DCB     "VerifyHeap",0                   ; Command Table: Command
        ALIGN
        DCD     |command2|                      ; Command Table: Code offset    -> Code @ &00000B3C
        DCD     &00010101                        ; Command Table: Infomation Word
        DCD     |syntax2|            ; Command Table: Syntax offset  -> String array: "Syntax: *VerifyHeap <address>",0
        DCD     |help2|               ; Command Table: Help offset    -> String array: "*VerifyHeap will check the integrity of the given heap.\r\rSyntax:"
        DCB     "Sliding_Heap",0                 ; Command Table: Command
        ALIGN
        DCD     &00000000                        ; Command Table: Code offset
        DCD     &00000000                        ; Command Table: Infomation Word
        DCD     &00000000                        ; Command Table: Syntax offset
        DCD     |help3|               ; Command Table: Help offset    -> String: "SlidingHeap is a memory manager that works by using `anchor poin"
        DCD     &00000000                        ; Command Table: End

|L000000CC.SWI_Table.String|
        DCB     "SlidingHeap",0                  ; SWI Table
        DCB     "Create",0                       ; SlidingHeap_Create
        DCB     "NewBlock",0                     ; SlidingHeap_NewBlock
        DCB     "ScrapBlock",0                   ; SlidingHeap_ScrapBlock
        DCB     "ExtendBlock",0                  ; SlidingHeap_ExtendBlock
        DCB     "HeapInfo",0                     ; SlidingHeap_HeapInfo
        DCB     "VerifyHeap",0                   ; SlidingHeap_VerifyHeap
        DCB     "NextFree",0                     ; SlidingHeap_NextFree
        DCB     "IncreaseSlots",0                ; SlidingHeap_IncreaseSlots
        DCB     "DescribeBlock",0                ; SlidingHeap_DescribeBlock
        DCB     "ShiftHeap",0                    ; SlidingHeap_ShiftHeap
        DCB     0
        ALIGN

|L0000013C.Initialisation_code|
        STMFD   R13!,{R0-R3,R14}                 ; Entry Point, Initialisation code, (Referenced)
        MOV     R0,#6     ; Claim
        MOV     R3,#&0100 ; 256-byte workspace
        SWI     XOS_Module
        STRVC   R2,[R12,#0] ; store block address in private word
        LDMFD   R13!,{R0-R3,PC} ; exit, returning error status in V flag

|L00000154.Finalisation_code|
        STMFD   R13!,{R0-R3,R14}                 ; Entry Point, Finalisation code, (Referenced)
        MOV     R0,#7       ; Free
        LDR     R2,[R12,#0] ; get address of block from private word
        SWI     XOS_Module
        LDMFD   R13!,{R0-R3,PC} ; exit, returning error status in V flag

|L00000168.SWI_handler_code|
        LDR     R12,[R12,#0]
        CMP     R11,#&0A                         ; =10
        ADDCC   PC,PC,R11,LSL #2                 ; Dynamic branch
        B       |Unknown|                     ; Ends
        B       |SlidingHeap_Create|                     ; Branch Table Offset 0, Ends
        B       |SlidingHeap_NewBlock|                   ; Branch Table Offset 1, Ends
        B       |SlidingHeap_ScrapBlock|                 ; Branch Table Offset 2, Ends
        B       |SlidingHeap_ExtendBlock|                ; Branch Table Offset 3, Ends
        B       |SlidingHeap_HeapInfo|                   ; Branch Table Offset 4, Ends
        B       |SlidingHeap_VerifyHeap|                 ; Branch Table Offset 5, Ends
        B       |SlidingHeap_NextFree|                   ; Branch Table Offset 6, Ends
        B       |SlidingHeap_IncreaseSlots|              ; Branch Table Offset 7, Ends
        B       |SlidingHeap_DescribeBlock|              ; Branch Table Offset 8, Ends
        B       |SlidingHeap_ShiftHeap|                      ; Branch Table Offset 9, Ends

|Unknown|
        ADR     R0,|Unknown_err|       ; -> Error Block Word: &000001E6
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|Unknown_err|
        DCD     &000001E6                        ; Error Block Word r/- (referenced)
        DCB     "Unknown SlidingHeap operation",0 ; Error Block String -/-
        ALIGN

|SlidingHeap_IncreaseSlots|
; On entry, R0 points to base of heap
; R1 holds new maximum number of slots desired in heap
; if R1 equals 0
;  then exit, returning current number of slots in R1
; else extend heap base to make room for increased number of slots

; on exit all registers preserved
        STMFD   R13!,{R0-R7,R14}
        LDR     R3,[R0,#4]                      ;old number of slots
        CMP     R1,#0                  ;if R1 equals zero, return,
        BEQ     |reportslots_exit|       ;supplying current slot count in R1
        SUBS    R6,R1,R3                        ;number of extra slots
        BLO     |decreaseslots|
        MOV     R7,R0                           ;store start of heap base
                                                ;(we are about to corrupt this)

        LDR     R0,[R7,#8]                      ;start of blocks
        LDR     R5,[R7,#12]                     ;end of last block...
        ADD     R5,R5,#4                        ;... start of following word
        SUB     R2,R5,R0                        ;R2 holds total length of blocks
        ADD     R1,R0,R6,LSL #4 ;R1 holds new start of blocks =
                                ;old start plus slots*16 (each is 16 bytes long)
        BL      |shiftblock|                    ;move heap blocks up

        MOV     R1,#0                           ;value to store in new slots
        MOV     R2,R6                           ;number of slots to initialise
        ADD     R0,R7,#&10                      ;start of current slots
        ADD     R0,R0,R3,LSL #4                 ;offset to first new slot
                                                ;R3 * 16 is end of old slots
        BL      |initheap_loop|                 ;initialise R2 slots
                                                ;starting from R0

        MOV     R1,R3                           ;old number of slots
        ADD     R2,R1,R6                        ;total new number of slots
        STR     R2,[R7,#4]                      ;update number of slots

        ADD     R0,R7,#&10                      ;get start of slots
        MOV     R5,R6,LSL #4                    ;offset by which heap has moved
        ;R1 still holds old number of slots, i.e. the number that need updating
            ;R7 holds heap base
        B       |shift_updateslots|               ;now update all old slots
                                          ;(exit is via SlidingHeap_ShiftHeap)

|decreaseslots|
        ; SlidingHeap_IncreaseSlots exit
        ADR     R0,decreaseslots_err       ; -> Error number &C02809
        ADD     R13,R13,#4             ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|decreaseslots_err|
        DCD       &00C02809                        ; Error number
        DCB     "Unable to decrease number of slots in heap",0
        ALIGN

|reportslots_exit|
        LDMFD  R13!,{R0-R7,R14}
        LDR    R1,[R0,#4] ;return current number of slots in R1
        ; SlidingHeap_IncreaseSlots exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        MOVNES  PC,R14 ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        MOV     PC,R14 ; 32-bit exit, caller flags corrupted


|SlidingHeap_Create|
 ; on entry R0 points to base of heap
 ; If R1 equals 2
 ;  then R2 holds max. number of sliding blocks
 ; else use default value of 15

 ; on exit R0,R1,R2 corrupted

        CMP     R1,#2
        MOVNE   R2,#&0F                          ; '2' code not found in R1
        CMP     R2,#0
        BLE     |Create_exit|                    ; if '2' specified, R2 must be supplied
        LDR     R1,heap_signature                ; -> String: "«Hz»"
        STR     R1,[R0,#0]
        STR     R2,[R0,#4]
        ADD     R1,R0,#&10                       ; offset to start of heap slots
        ADD     R1,R1,R2,LSL #4                  ; plus R2 4-byte words makes
                                                 ; total size of heap base
        STR     R1,[R0,#8]
        STR     R1,[R0,#&00C]                    ; =12
        ADD     R0,R0,#&10                       ; R0+=16
        MOV     R1,#0
|initheap_loop|
        CMP     R2,#0                            ; loop down to 0
        BEQ     |initheap_jumpout|
        STR     R1,[R0,#0]
        STR     R1,[R0,#4]
        STR     R1,[R0,#8]
        STR     R1,[R0,#&00C]                    ; =12
        ADD     R0,R0,#&10                       ; =16
        SUB     R2,R2,#1
        B       |initheap_loop|                      ; Ends
|initheap_jumpout|
        LDR     R1,block_signature               ; -> String: "Blck"
        STR     R1,[R0,#0]
        MOV     PC,R14                           ; Function exit, Ends
; base+0        = heap signature word
; base+4        = max number of blocks
; base+8        = start of blocks in heap
; base+12       = end of blocks in heap

; R2  blocks of 4 words
;   slot+0      = pointer to start of block
;   slot+4      = pointer to anchor word
;   slot+8      = block size
;   slot+12     = pointer to block name string

; base+12+ R2*16      = block signature

|SlidingHeap_NewBlock|
 ; on entry R0 holds base address of sliding heap
 ; R1 holds address of anchor word (previously created)
 ; R2 holds size of block (rounded up to nearest word)
 ;  Must check that there is enough space & increase Wimpslot if necessary
 ;  *before* calling SlidingHeap_NewBlock!
 ; R3 points to name of block ( should be R1+4)

 ; on exit all registers preserved

        STMFD   R13!,{R0-R7,R14}
        ADD     R4,R0,#&10                       ; start of heap slots
        LDR     R5,[R0,#4]                       ; R5 = number of slots in heap
|freeslot_loop|
        LDR     R6,[R4,#0]
        CMP     R6,#0                            ; check for empty slot
        BEQ     |newblock|
        ADD     R4,R4,#&10                       ; =16
        SUBS    R5,R5,#1
        BNE     |freeslot_loop|
        ADR     R0,|nonefree|       ; -> Error Block Word: &00C02800
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        ; SlidingHeap_NewBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return


|nonefree|
        DCD     &00C02800                        ; Error Block Word r/- (referenced)
        DCB     "No more free slots in heap",0   ; Error Block String -/-
        ALIGN

|newblock|
        STR     R1,[R4,#4]                       ; store anchor address at slot+4
        ADD     R2,R2,#3
        BIC     R2,R2,#2_11                     ; round requested block size up
                                                  ; to nearest word
        STR     R2,[R4,#8]                        ; store size at slot+8
        MOV     R5,R0                             ; shuffle registers to call SWI
        MOV     R6,R1                             ;
        MOV     R0,R3                             ;
        MOV     R1,R3                             ;
        SWI     XOS_ValidateAddress
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit on error
        MOVCS   R3,#0                            ; carry set if bad address
        MOV     R1,R6                            ; restore registers
        MOV     R0,R5
        CMP     R3,#0
        ADREQ   R3,unknown_block                 ; -> String: "Unknown block",0
        STR     R3,[R4,#&00C]                    ; store pointer to block name at
                                                 ; slot+12
        LDR     R5,[R0,#&00C]                    ; pointer to first word after end
                                                 ; of heap (base+12)
        ADD     R5,R5,#4                         ; allow for block signature
        STR     R5,[R4,#0]                       ; store new block start at slot+0
        STR     R5,[R1,#0]                       ; and back into anchor address
        ADD     R5,R5,R2
        STR     R5,[R0,#&00C]                    ; store new heap end in base+12
        LDR     R4,block_signature               ; -> String: "Blck"
        STR     R4,[R5,#0]                       ;mark end of block so we can
                                                 ;check for heap corruption later

        ; SlidingHeap_NewBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

unknown_block
        DCB     "Unknown block",0        ; String r/- (referenced)
        ALIGN

|SlidingHeap_ScrapBlock|
 ; on entry R0 points to heap base
 ; R1 points to address of anchor word

 ; on exit all registers preserved

; Wimpslot must be shrunk manually after this call if heap has contracted
; enough to allow it
        STMFD   R13!,{R0-R7,R14}
        ADD     R2,R0,#&10                       ; base+16
        LDR     R3,[R0,#4]                       ; number of slots
|scrap_loop|
        LDR     R4,[R2,#4]                       ;get anchor for slot
        CMP     R4,R1                            ;is it this one?
        BEQ     |scrapblock|
        ADD     R2,R2,#&10                       ;next slot
        SUBS    R3,R3,#1
        BGT     |scrap_loop|
        ADR     R0,|noanchor|       ; -> Error Block Word: &00C02807
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        ; SlidingHeap_ScrapBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|noanchor|
        DCD     &00C02807                        ; Error Block Word r/- (referenced)
        DCB     "Couldn\'t find anchor in heap (ScrapBlock)",0 ; Error Block String -/-
        ALIGN

|scrapblock|
        MOV     R4,#0
        STR     R4,[R1,#0]                        ;zero anchor word
        LDR     R7,[R0,#&00C]                     ;get start of blocks from base+12
        LDR     R5,[R2,#0]                        ;get start of this block
        SUB     R7,R7,R5                          ;offset
        LDR     R6,[R2,#8]                        ;get block size
        SUB     R7,R7,R6                         ;offset to start of following data
        ADD     R7,R7,#4                         ;total amount to slide by
        LDR     R6,[R2,#8]                        ;get block size
        ADD     R6,R6,R5                          ;size + start = end
        SUB     R5,R5,#4
        STMFD   R13!,{R0-R3}
        MOV     R1,R6
        MOV     R2,R5
        MOV     R3,R7
        BL      |shiftup_blockdata|               ;move stuff up from after block
        LDMFD   R13!,{R0-R3}                        ;restore corrupted registers
        LDR     R1,[R0,#4]                          ;number of blocks at base+4
        LDR     R7,[R2,#8]                          ;block size (again!)
        ADD     R7,R7,#4                            ;including block sig
        MOV     R5,#0
        STR     R5,[R2,#0]                          ;zero block start
        STR     R5,[R2,#4]                          ;and anchor pointer
        STR     R5,[R2,#8]                          ;and block size...
        STR     R5,[R2,#&00C]                       ;and name string....
        ADD     R2,R0,#&10                         ;point R2 to first slot in heap
|scrap_adjustotherslots|
        LDR     R5,[R2,#0]                         ;start of block
        CMP     R5,#0
        BEQ     |scrap_slotisblank|
        CMP     R5,R6                              ;has this block just slid?
        SUBGE   R5,R5,R7               ;then adjust address by amount we slid by
        STR     R5,[R2,#0]                         ;and store back
        LDR     R4,[R2,#4]                         ;address of anchor word
        STR     R5,[R4,#0]                       ;update also with new block start
|scrap_slotisblank|
        ADD     R2,R2,#&10                     ;next slot
        SUBS    R1,R1,#1                     ;decrement block count
        BNE     |scrap_adjustotherslots|
        LDR     R5,[R0,#&00C]                    ; =12
        SUB     R5,R5,R7
        STR     R5,[R0,#&00C]                    ; =12
        ; SlidingHeap_ScrapBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

|SlidingHeap_ExtendBlock| ; SlidingHeap_ExtendBlock
; on entry R0 points to heap base
; R1 points to anchor word
; R2 points to desired new block size
; Wimpslot must have been manually extended before calling this SWI
; if not enough space for heap to grow
; and must be manually shrunk afterwards if heap has shrunk enough to allow it

; on exit all registers preserved
        STMFD   R13!,{R0-R7,R14}
        ADD     R3,R0,#&10                       ;point to 1st slot in heap
        LDR     R4,[R0,#4]                       ;max no of blocks
|extend_loop|
        LDR     R5,[R3,#4]                       ;anchor word for this slot
        CMP     R5,R1                            ;is it right one?
        BEQ     |extendblock|
        ADD     R3,R3,#&10                       ; =16
        SUBS     R4,R4,#1
        BGT     |extend_loop|       ; -> Error Block Word: &00C02808
        ADR	R0,|extend_notfound|
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        ; SlidingHeap_ExtendBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|extend_notfound|
        DCD     &00C02808                        ; Error Block Word r/- (referenced)
        DCB     "Couldn\'t find anchor in heap (ExtendBlock)",0 ; Error Block String -/-
        ALIGN

|extendblock|
        ADD     R2,R2,#3                        ;round new block size up
        BIC     R2,R2,#2_11                     ;to nearest word
        LDR     R4,[R3,#0]                      ;start of block
        LDR     R5,[R3,#8]                      ;block size
        ADD     R4,R4,R5
        ADD     R4,R4,#4                        ;end of block+sig
        SUB     R7,R2,R5                        ;subtract from new block size
                                                ;offset now in R7
        ADD     R5,R7,R4             ;adjust end of block address by this offset
        LDR     R6,[R0,#&00C]                   ;end of heap blocks
        SUB     R6,R6,R4                        ;distance to old block end
        STMFD   R13!,{R0-R3}
        MOV     R0,R4
        MOV     R1,R5
        MOV     R2,R6
        BL      |shiftblock|
        LDMFD   R13!,{R0-R3}
        MOV     R6,R7                            ;restore offset
        STR     R2,[R3,#8]                       ;store new block size
        LDR     R1,[R0,#&00C]                    ;get end of heap blocks
        ADD     R1,R1,R6                         ;plus offset
        STR     R1,[R0,#&00C]                    ;store new end at base+12
        LDR     R1,[R3,#0]                       ;get start of block
        ADD     R1,R1,R2                         ;point to end of new block
        LDR     R7,block_signature               ; -> String "Blck"
        STR     R7,[R1,#0]                       ;poke in block sig to mark end
        ADD     R2,R0,#&10                       ;start of slots
        LDR     R1,[R3,#0]                       ;get start of block
        LDR     R0,[R0,#4]                       ;get number of slots
|extend_updateslot|
        CMP     R0,#0
        BEQ     extendblock_finished             ;check for last slot
        LDR     R3,[R2,#0]                       ;start of block
        CMP     R3,R1                            ;is it this block?
        ADDGT   R3,R3,R6                         ;if so, apply offset
        STRGT   R3,[R2,#0]
        LDRGT   R7,[R2,#4]                       ;update anchor word
        STRGT   R3,[R7,#0]
        ADD     R2,R2,#&10                       ;next slot
        SUB     R0,R0,#1
        B       |extend_updateslot|              ; Ends

extendblock_finished
        ; SlidingHeap_ExtendBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

|SlidingHeap_HeapInfo|
; On entry R0 points to heap base
; on exit all registers preserved
        STMFD   R13!,{R0-R7,R14}
        MOV     R7,R0                            ;preserve heap base address
        SWI     XOS_WriteS
        DCB     "\r\nHeap information requested\r\n\r\nGenerated by SlidingHeap 2.11, © Steven Haslam 1992 (16 Dec 2002)\r\n\r\nHeap base : &",0 ; Inline string -/-
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if error
        MOV     R1,R12                           ; get private word in R1
        MOV     R2,#&0100                        ; buffer size =256
        SWI     XOS_ConvertHex8
        SWIVC   XOS_Write0                       ;print address of heap base
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        SWI     XOS_WriteS
        DCB     "\r\nSlots available in heap : ",0
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        LDR     R0,[R7,#4]                       ;get number of slots
        MOV     R1,R12                           ;workspace again
        MOV     R2,#&0100                        ; =256
        SWI     XOS_ConvertCardinal4         ;print number of slots
        SWIVC   XOS_Write0
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        SWI     XOS_WriteS
        DCB     "\r\nSlots used : ",0            ; Inline string -/-
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        ADD     R1,R7,#&10                       ;first slot
        LDR     R3,[R7,#4]                       ;number of slots
        MOV     R0,#0                            ;start count
|info_slotcount|
        LDR     R2,[R1,#0]                       ;start of block
        CMP     R2,#0                            ;is it blank?
        ADDNE   R0,R0,#1                         ; if not, increment count
        ADD     R1,R1,#&10                       ;next slot
        SUBS    R3,R3,#1
        BNE     |info_slotcount|
        MOV     R6,R0                            ;number of used slots in R6
        MOV     R1,R12                           ;workspace
        MOV     R2,#&0100                        ; =256
        SWI     XOS_ConvertCardinal4
        SWIVC   XOS_Write0                       ;print no. of slots used
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        SWI     XOS_WriteS
        DCB     "\r\nTop of heap : &",0
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        LDR     R0,[R7,#&00C]                    ;end of heap blocks
        SWI     XOS_ConvertHex8
        SWIVC   XOS_Write0                       ;print highest address in heap
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        SWI     XOS_WriteS
        DCB     "\r\n\r\n",0
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        CMP     R6,#0                            ;number of used slots
        BEQ     heapinfo_finished
        SWI     XOS_WriteS
        DCB     "Blocks: (not necessarily in the order as in the heap)\r\n\r\n| Address   | Length      | Name\r\n",0 ; Inline string -/-
        ALIGN
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        ADD     R6,R7,#&10                       ;start of slots
        LDR     R4,[R7,#4]                       ;number of slots
|info_slotinfo|
        LDR     R5,[R6,#0]                       ;address of block
        CMP     R5,#0
        BEQ     |info_nextslot|
        SWI     XOS_WriteI+"|"
        SWIVC   XOS_WriteI+" "
        SWIVC   XOS_WriteI+"&"
        MOVVC   R0,R5
        MOVVC   R1,R12
        MOVVC   R2,#&0100                        ; =256
        SWIVC   XOS_ConvertHex8
        SWIVC   XOS_Write0
        SWIVC   XOS_WriteI+" "
        SWIVC   XOS_WriteI+"|"
        SWIVC   XOS_WriteI+" "
        LDRVC   R0,[R6,#8]                      ;size of block
        SWIVC   XOS_ConvertFixedFileSize
        SWIVC   XOS_Write0
        SWIVC   XOS_WriteI+" "
        SWIVC   XOS_WriteI+"|"
        SWIVC   XOS_WriteI+" "
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        LDR     R1,[R6,#&00C]                    ;pointer to block name
|info_blockname|
        LDRB    R0,[R1],#1
        CMP     R0,#&20                          ;if control character...
        BLT     return                           ;print return & exit
        SWI     XOS_WriteC                         ;print name of block
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if error
        B       |info_blockname|
return
        SWI     XOS_WriteI+13
        SWIVC   XOS_WriteI+10
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
|info_nextslot|
        ADD     R6,R6,#&10                       ; =16
        SUBS    R4,R4,#1
        BNE     |info_slotinfo|
heapinfo_finished
        ; SlidingHeap_HeapInfo exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

|SlidingHeap_VerifyHeap|
; On entry, R0 points to heap base
; on exit, all registers preserved
        STMFD   R13!,{R0-R7,R14}
        ADD     R1,R0,#&10                       ;first slot
        SWI     XOS_ValidateAddress              ;check base is at valid address
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if error
        BCS     |heapinvalid|
        LDR     R1,[R0,#&00C]                    ;check end of heap blocks
        ADD     R1,R1,#4
        SWI     XOS_ValidateAddress
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        BCS     |heapinvalid|
        LDR     R1,[R0,#0]
        LDR     R2,heap_signature                ; -> String: "«Hz»"
        CMP     R1,R2 ; check heap ID using special signature
        BNE     |heap_nosig|
        LDR     R1,[R0,#8]                       ;check start of heap blocks
        LDR     R1,[R1,#0]
        LDR     R2,block_signature               ; -> String: "Blck"
                      ;check for string at end of heap base
        CMP     R1,R2
        BNE     |heap_nostart|
        LDR     R1,[R0,#4]                       ;max number of slots
        ADD     R0,R0,#&10                       ;first slot
|checkslots|
        LDR     R3,[R0,#0]                       ;start of block
        CMP     R3,#0                            ;is it in use?
        BEQ     |checkforlastslot|               ;if last then exit
        LDR     R4,[R0,#8]                       ;block size
        ADD     R3,R3,R4                         ;end of block
        LDR     R3,[R3,#0]                       ;last word of block
        LDR     R2,block_signature               ; -> String "Blck"
        CMP     R2,R3
        BEQ     |goodblocksig|                 ;else block bad
        LDR     R0,[R0,#&00C]                  ;block name
        MOV     R1,R12
        ADD     R1,R1,#4                         ;workspace+4
        MOV     R2,#short_workspace              ;length 256-4
        ADR     R3,|overflowtemplate|            ;get length of template
        LDR     R4,[R3],#4                       ;and increment R3
                                              ;to point to actual string
        SWI     XOS_SubstituteArgs               ;substitute in block name
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if VS
        MOV     R3,#0
        SUB     R2,R2,#1
        STRB    R3,[R1,R2]                     ;zero-terminate result string
        LDR     R0,|overflow_err|              ;get error number
        STR     R0,[R12,#0]               ;and put into 1st word of workspace
        MOV     R0,R12                    ;R0 points to home-made error block
        ADD     R13,R13,#4                ;skip first stack entry (old R0)
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|goodblocksig|
;R0 points to slot
        LDR     R2,[R0,#4]                        ;anchor
        LDR     R2,[R2,#0]                     ;anchor contents (start of block)
        LDR     R3,[R0,#0]                     ;start of block (from slot data)
        CMP     R2,R3
        BEQ     |checkforlastslot|              ;All OK, exit back to loop
                                                ;otherwise report error
make_badanchor_errblock
        LDR     R0,[R0,#&00C]                   ;block name
        MOV     R1,R12
        ADD     R1,R1,#4                        ;workspace+4
        MOV     R2,#short_workspace             ;length of remaining buffer
        ADR     R3,|badanchortemplate|          ;get length of template string
        LDR     R4,[R3],#4                      ;and increment R3
                                                ;to point to actual string
        SWI     XOS_SubstituteArgs
        LDMVSFD R13!,{R0-R7,PC}                  ; Function exit if error
        MOV     R3,#0
        SUB     R2,R2,#1                         ;length of result string -1
        STRB    R3,[R1,R2]                       ;zero-terminate string
        LDR     R0,|badanchor_err|               ;get error number
        STR     R0,[R12,#0]                      ;store in 1st word of workspace
        MOV     R0,R12                           ;R0 now points to error block
        ADD     R13,R13,#4                ;skip first stack entry (old R0)
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return
; error exit
; Normal exit is via 'checkforlastslot'


|checkforlastslot|
;R0 points to current slot
;R1 holds slot counter
        ADD     R0,R0,#&10                       ; =16
        SUBS    R1,R1,#1
        BGT     |checkslots|                     ;continue with check loop
        ; SlidingHeap_VerifyHeap exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

|SlidingHeap_NextFree|
; On entry, R0 points to base of heap
; on exit, R0 points to first word after end of heap
        LDR     R0,[R0,#&00C]                    ;end of current heap blocks
        ADD     R0,R0,#4                         ;next word
        MOV     PC,R14                             ; Function exit, Ends

|SlidingHeap_DescribeBlock|
; On entry, R0 points to base of heap
; R1 points to anchor word
; on exit, R0 points to start of block
; R1 points to anchor word
; R2 holds block size
; R3 points to block name string
        STMFD   R13!,{R0-R7,R14}
        ADD     R2,R0,#&10                       ;start of slots
        LDR     R3,[R0,#4]                       ;number of slots
|describe_slotloop|
        CMP     R3,#0                            ;all slots checked?
        BEQ     |describe_noanchor|
        LDR     R4,[R2,#4]                       ;pointer to anchor word
        CMP     R4,#0                            ;slot unused?
        BEQ     |describe_slotunused|
        CMP     R4,R1
        BEQ     |describe_slotfound|
|describe_slotunused|
        SUB     R3,R3,#1                         ;decrement slot counter
        ADD     R2,R2,#&10                       ;next slot
        B       |describe_slotloop|                      ; Ends
|describe_noanchor|
        ADR     R0,|describe_noanchor_err|       ; -> Error Block Word: &00C0280B
        ; SlidingHeap_DescribeBlock exit
        ADD     R13,R13,#4             ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|describe_noanchor_err|
        DCD     &00C0280B                        ; Error Block Word r/- (referenced)
        DCB     "Couldn\'t find anchor in heap (DescribeBlock)",0 ; Error Block String -/-
        ALIGN

|describe_slotfound|
        MOV     R0,R2                              ;pointer to start of slot
        ADD     R13,R13,#4             ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        LDMIA   R0,{R0-R3}                         ;load slot data in R0-R3
        ; SlidingHeap_DescribeBlock exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        MOVNES  PC,R14 ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        MOV     PC,R14 ; 32-bit exit, caller flags corrupted

|SlidingHeap_ShiftHeap|
; On entry, R0 points to base of heap
; R1 points to new address for base of heap
; on exit, all registers preserved
        STMFD   R13!,{R0-R7,R14}
        MOV     R7,R1                           ;destination address
        MOV     R6,R0                           ;start of heap base
        BL      |SlidingHeap_NextFree|
                            ;R0 points to first word after end of heap
        RSB     R2,R6,R0                ;total size of heap, base plus blocks
        MOV     R0,R6                             ;restore parameters
        MOV     R1,R7
        BL      |shiftblock|                      ;shift whole heap
        SUB     R5,R7,R6                          ;get offset (+/-) in R5
        ADD     R0,R7,#&10                       ;new start of slots
        LDR     R1,[R7,#4]                       ;number of slots
|shift_updateslots|
        LDR     R2,[R0,#0]                       ;start of block
        CMP     R2,#0
        ADDNE   R2,R2,R5                         ;...if not empty...
        STRNE   R2,[R0,#0]                       ;update start by offset amount
        LDRNE   R3,[R0,#4]                       ;get anchor
        STRNE   R2,[R3,#0]                       ;update anchor too
        ADD     R0,R0,#&10                       ;next slot
        SUBS    R1,R1,#1
        BNE     |shift_updateslots|
        LDR     R0,[R7,#8]                       ;start of blocks in heap
        ADD     R0,R0,R5
        STR     R0,[R7,#8]                       ;update start of blocks by offset
        LDR     R0,[R7,#&00C]
        ADD     R0,R0,R5
        STR     R0,[R7,#&00C]
        ; SlidingHeap_ShiftHeap exit
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        LDMNEFD R13!,{R0-R7,PC}^ ; 26-bit exit - return, restoring flags
        MSRVS   CPSR_f,#0 ; forcibly clear flags, if V set
        LDMFD   R13!,{R0-R7,PC} ; 32-bit exit, caller flags corrupted

|Create_exit|
        ; SlidingHeap_Create exit
        ADR     R0,|create_err|       ; -> Error Block Word: &00C02802
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|create_err|
        DCD     &00C02802                        ; Error Block Word r/- (referenced)
        DCB     "You must have at least one block in the heap!",0 ; Error Block String -/-
        ALIGN

|heapinvalid|
        ; SlidingHeap_VerifyHeap exit
        ADR     R0,|heapinvalid_err|       ; -> Error Block Word: &00C0280A
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|heapinvalid_err|
        DCD     &00C0280A                        ; Error Block Word r/- (referenced)
        DCB     "Heap is not in valid memory",0  ; Error Block String -/-
        ALIGN

|heap_nosig|
        ; SlidingHeap_VerifyHeap exit
        ADR     R0,|heap_nosigerr|       ; -> Error Block Word: &00C02803
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|heap_nosigerr|
        DCD     &00C02803                        ; Error Block Word r/- (referenced)
        DCB     "Heap ID corrupted (Bad signature)",0 ; Error Block String -/-
        ALIGN

|heap_nostart|
        ; SlidingHeap_VerifyHeap exit
        ADR     R0,|heap_nostart_err|       ; -> Error Block Word: &00C02804
        ADD     R13,R13,#4        ; R0 is first item on stack - skip
        LDMFD   R13!,{R1-R7,R14}
        TEQ     PC,PC ; check whether in 26-bit or 32-bit mode
        ORRNES  PC,R14,#V_flag ; 26-bit mode - set V flag and return
        MSRVC   CPSR_f,#V_flag ; 32-bit mode - ensure that V flag is set...
        MOV     PC,R14            ; ...and return

|heap_nostart_err|
        DCD     &00C02804                        ; Error Block Word r/- (referenced)
        DCB     "Start of heap corrupted (Bad signature)",0 ; Error Block String -/-
        ALIGN

|overflowtemplate|
        DCD     &24           ;length of template string
        DCB     "Block overflow in Sliding Heap (%*0)"
;length is given in first word so no terminator needed
|overflow_err|
        DCD    &00C02801      ;error number

|badanchortemplate|
        DCD     &24
        DCB     "Anchor does not point to block (%*0)"
|badanchor_err|
        DCD      &00C02806

heap_signature
        DCB     "«Hz»"
block_signature
        DCB     "Blck"

|command2| ; *VerifyHeap
        STR     R14,[R13,#-4]!  ;store R14 on descending stack
        LDR     R12,[R12,#0]    ;get workspace
        MOV     R1,R0           ;command tail string
        MOV     R0,#&10             ;  expects base 16
        SWI     XOS_ReadUnsigned
        MOVVC   R0,R2            ;R2 holds heap base (we hope)
        BLVC    |SlidingHeap_VerifyHeap|
        ADRVC   R0,heap_ok
        SWIVC   XOS_Write0          ;output OK message
        LDR     PC,[R13],#4 ; exit, returning error status in V flag

heap_ok
        DCB "Heap checked out OK\r\n",0
        ALIGN

|help2|
        DCB     "*VerifyHeap will check the integrity of the given heap.\r\r"
|syntax2|
        DCB     "Syntax: *VerifyHeap <address>",0 ; String array r/- (referenced)
        ALIGN

|command1| ; *HeapInfo
        STR     R14,[R13,#-4]!         ;store R14 on descending stack
        LDR     R12,[R12,#0]           ;get workspace
        MOV     R1,R0                  ;command tail string
        MOV     R0,#&10                    ;  expects base 16
        SWI     XOS_ReadUnsigned
        MOVVC   R0,R2                  ;R2 holds heap base (we hope)
        BLVC    |SlidingHeap_HeapInfo| ; SlidingHeap_HeapInfo
        LDR     PC,[R13],#4 ; exit, returning error status in V flag

|help1|
        DCB     "*HeapInfo will display information on the given sliding heap.\r\r"
|syntax1|
        DCB     "Syntax: *HeapInfo <address>",0 ; String array r/- (referenced)

|help3|
        DCB     "SlidingHeap is a memory manager that works by using `anchor points` into an area of memory; it is rather like Acorn C\'s `flex` library, however it is suitable for use in BASIC/ARM code programs. There is a set of BASIC procedures to interface with the sliding heap manager, which will also automatically increase and decrease the size of a WIMP task\'s memory area as required.\r" ; String -/- (referenced)
        DCB     "\r"
        DCB     "For more information, contact Steven Haslam at one of the following addresses:\r"
        DCB     "\r"
        DCB     "E-Mail:\r"
        DCB     "\xA0","FidoNet:  2:250/116.3, 2:254/27.0, 2:252/102.0, 2:254/405.0\r"
        DCB     "\r"
        DCB     "Snail-Mail:\r"
        DCB     "\r"
        DCB     "Steven Haslam\r"
        DCB     "\xA0","112 Keighley Road\r"
        DCB     "\xA0\xA0","Colne\r"
        DCB     "\xA0\xA0\xA0","Lancashire\r"
        DCB     "\xA0\xA0\xA0\xA0","BB8 0PH",0
        ALIGN

|shiftup_blockdata|
; On entry, R0 points to heap base
; R1 points to end of block
; R2 points to start of block
; R3 = amount to slide heap up by

; On exit, R0-R3 corrupted

        STR     R14,[R13,#-4]!                   ;R14 on mini-stack
;        TST     R2,#3
;        BNE     |startnotaligned|                    ;not word-aligned
;|nonaligned_jumpback|
;        TST     R1,#3
;        BNE     |endnotaligned|                   ;not word-aligned
        SUBS    R3,R3,#&10
        BLT     |shift_8|                        ;less than 16 bytes to move
        SUBS    R3,R3,#&10
        BLT     |shift_16|                       ;less than 32 bytes to move
        STMFD   R13!,{R4-R9}                     ;we are about to corrupt these
|shift_32|
        LDMIA   R1!,{R0,R4-R9,R14}               ;load stuff from after end
        STMIA   R2!,{R0,R4-R9,R14}               ;and write from start
        SUBS    R3,R3,#&20                       ; five registers' worth of data
        BGE     |shift_32|
        CMN     R3,#&20                          ;check block size against -32
        LDMEQFD R13!,{R4-R9,PC}                  ; Function exit if EQ
        LDMFD   R13!,{R4-R9}                     ;restore registers
|shift_16|
        ADDS    R3,R3,#&10
        BLT     |shift_8|
        STMFD   R13!,{R4,R5}                     ;preserve R4, R5
        LDMIA   R1!,{R0,R4,R5,R14}               ;shift another 16 bytes
        STMIA   R2!,{R0,R4,R5,R14}
        LDMEQFD R13!,{R4,R5,PC}                  ; Function exit if EQ
        LDMFD   R13!,{R4,R5}
        SUB     R3,R3,#&10                       ; =16
|shift_8|
        ADDS    R3,R3,#8
        BLT     |shift_4|
        LDMIA   R1!,{R0,R14}                     ;shift another 8 bytes
        STMIA   R2!,{R0,R14}
        LDREQ   PC,[R13],#4                      ; Function exit if EQ
        SUB     R3,R3,#8
|shift_4|
        ADDS    R3,R3,#4
        BLT     |lastword|
        LDR     R0,[R1],#4                       ;just one register's worth now
        STR     R0,[R2],#4
        LDREQ   PC,[R13],#4                      ; Function exit if EQ
        SUB     R3,R3,#4
|lastword|
        ADDS    R3,R3,#4
        LDREQ   PC,[R13],#4                      ; Function exit if EQ
        LDR     R0,[R1,#0]                ;grab last word from block end itself
|shift_byte|
        STRB    R0,[R2],#1
        MOV     R0,R0,LSR #8
        SUBS    R3,R3,#1
        BGT     |shift_byte|
        LDR     PC,[R13],#4                      ; Function exit, Ends
;-------------------------------------------------------------------------------

;|startnotaligned|
;        LDRB    R0,[R1],#1
;        STRB    R0,[R2],#1
;        SUBS    R3,R3,#1
;        LDREQ   PC,[R13],#4                      ; Function exit if EQ
;        TST     R2,#3                       ;have we reached word boundary yet?
;        BNE     |startnotaligned|
;        B       |nonaligned_jumpback|      ; note that R1 will now be non-aligned!
;;-------------------------------------------------------------------------------
;
;|endnotaligned|
;        STMFD   R13!,{R11,R12}
;        AND     R12,R1,#3                      ;get bottom two bits in R12
;        BIC     R1,R1,#3                       ;clear bottom bits
;        MOV     R12,R12,LSL #3                 ;times 8
;        RSB     R11,R12,#&20                   ;32 - R12
;                               ;R11 holds no. of bits to shift right by
;                               ;R12 holds no. of bits to shift left by
;        LDR     R0,[R1],#4                     ;get full word from end of block
;        MOV     R0,R0,LSR R12                  ;shift by no of significant bits
;                                               ;to get non-aligned data
;        SUBS    R3,R3,#&10                       ; =16
;        BLT     |lessthan8|
;        SUBS    R3,R3,#&10                       ; =16
;        BLT     |lessthan16|
;        STMFD   R13!,{R4-R10}           ;stack registers we're about to corrupt
;|atleast32|
;        LDMIA   R1!,{R4-R10,R14}         ;load 8 registers from address in R1
;                                         ;(32 bytes)
;        ORR     R0,R0,R4,LSL R11
;        MOV     R4,R4,LSR R12
;        ORR     R4,R4,R5,LSL R11
;        MOV     R5,R5,LSR R12            ;transfer data along through R0
;                                         ;between registers in the block
;        ORR     R5,R5,R6,LSL R11         ;masking left and right as appropriate
;        MOV     R6,R6,LSR R12
;        ORR     R6,R6,R7,LSL R11
;        MOV     R7,R7,LSR R12
;        ORR     R7,R7,R8,LSL R11
;        MOV     R8,R8,LSR R12
;        ORR     R8,R8,R9,LSL R11
;        MOV     R9,R9,LSR R12
;        ORR     R9,R9,R10,LSL R11
;        MOV     R10,R10,LSR R12
;        ORR     R10,R10,R14,LSL R11
;        STMIA   R2!,{R0,R4-R10}          ;then store to destination address R2
;        MOV     R0,R14,LSR R12
;        SUBS    R3,R3,#&20                       ; =" " (32)
;        BGE     |atleast32|
;        CMN     R3,#&20                          ;check for all data transferred
;                                                 ;in last loop
;        LDMEQFD R13!,{R4-R12,PC}                 ; Function exit if EQ
;        LDMFD   R13!,{R4-R10}
;|lessthan16|
;        ADDS    R3,R3,#&10                       ; =16
;        BLT     |lessthan8|                      ;we're about to corrupt these
;        STMFD   R13!,{R4-R6}                     ;load 4 registers, 16 bytes
;        LDMIA   R1!,{R4-R6,R14}
;        ORR     R0,R0,R4,LSL R11
;        MOV     R4,R4,LSR R12
;        ORR     R4,R4,R5,LSL R11
;        MOV     R5,R5,LSR R12
;        ORR     R5,R5,R6,LSL R11         ;more transfers to get it word-aligned
;        MOV     R6,R6,LSR R12
;        ORR     R6,R6,R14,LSL R11
;        STMIA   R2!,{R0,R4-R6}                   ;save at R2
;        LDMEQFD R13!,{R4-R6,R11,R12,PC}          ; Function exit if EQ
;        LDMFD   R13!,{R4-R6}
;        SUB     R3,R3,#&10                       ; =16
;        MOV     R0,R14,LSR R12
;|lessthan8|
;        ADDS    R3,R3,#8
;        BLT     |lessthan4|
;        STR     R4,[R13,#-4]!                 ;stack R4
;        LDMIA   R1!,{R4,R14}
;        ORR     R0,R0,R4,LSL R11              ;shift data along via another
;        MOV     R4,R4,LSR R12                 ;couple of registers
;        ORR     R4,R4,R14,LSL R11
;        STMIA   R2!,{R0,R4}
;        LDMEQFD R13!,{R4,R11,R12,PC}             ; Function exit if EQ
;        LDR     R4,[R13],#4
;        SUB     R3,R3,#8
;        MOV     R0,R14,LSR R12
;|lessthan4|
;        ADDS    R3,R3,#4
;        BLT     |grabend|
;        LDR     R14,[R1],#4
;        ORR     R0,R0,R14,LSL R11               ;grab 1 word and shift it
;        STR     R0,[R2],#4
;        LDMEQFD R13!,{R11,R12,PC}                ; Function exit if EQ
;        SUB     R3,R3,#4
;        MOV     R0,R14,LSR R12
;|grabend|
;        ADDS    R3,R3,#4
;        LDMEQFD R13!,{R11,R12,PC}                ; Function exit if EQ
;        LDR     R14,[R1,#0]                      ;load from end of block itself
;        ORR     R0,R0,R14,LSL R11
;|lastbytes|
;        STRB    R0,[R2],#1
;        MOV     R0,R0,LSR #8
;        SUBS    R3,R3,#1
;        BGT     |lastbytes|
;        LDMFD   R13!,{R11,R12,PC}                ; Function exit, Ends
;-------------------------------------------------------------------------------

|shiftblock|
; on entry, R0 holds old end of block
; R1 holds new end of block
; R2 holds distance between R1 and end of heap
         STMFD   R13!,{R0-R4,R14}                 ; Function entry
        CMP     R0,R1
        BLT     |shift_fromend|
|shift_fromstart|
        LDR     R3,[R0],#4                       ;copy from start of old block
        STR     R3,[R1],#4                       ;...to start of new
        SUBS    R2,R2,#4
        BPL     |shift_fromstart|
        LDMFD   R13!,{R0-R4,PC}                  ; Function exit, Ends

|shift_fromend|
        LDR     R3,[R0,R2]                      ;copy from end of old block
        STR     R3,[R1,R2]                      ;...to end of new
        SUBS    R2,R2,#4
        BPL     |shift_fromend|
        LDMFD   R13!,{R0-R4,PC}                  ; Function exit, Ends

        END

